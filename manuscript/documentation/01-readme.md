# README

A project **README** is often the first thing people see at npm or GitHub when they find the project. Project site is another entry point. Sometimes they use the same content or you could design a separate landing page for the site.

A good README can "sell" the project to a potential user. A badly written one can scare users away even if the functionality is solid. Sometimes the developers don't understand this and as a user you may have to dig beyond the surface to find the value.

## What a README Should Contain

README should describe briefly what the package is about before delving into the details. A high level overview of the functionality and why the package was developed is enough. By doing this well, you save time as it will either attract people that have the same problem or make them understand the package isn't something they need.

Examples convey how to use the package. Ideally you are able to run them as tests. Besides making sure the examples work, this is also a rough way of **acceptance testing**. It's a good idea to start designing a package from writing the README as this forces you to think about the API carefully from the user point of view, it forces you to come up with a design you can document with minimal effort.

If the package is small, you can include its entire API documentation in the README. For bigger packages it can make sense to push the information below separate documents and host the information on the package site. Too big README can also mean you have to split up your package somehow. This is where the **monorepo** approach may come in handy.

You should include licensing information at the end of the README as that is a good convention to have. You can also mention sponsors and maintainers there so they get the visibility they have earned.

## Automating README Fields

TODO: markdown-magic + pulling meta from package.json
TODO: TOC generation

## Testing Examples

TODO

## Conclusion

TODO
